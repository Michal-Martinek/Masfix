; test run-like behaviour of compile time directives

%include "io"

%vm_runtime_delim()

; %include "control"
%macro ldReg(val) {
	ld %val
}
ld !ldReg(0)
ld 7
%macro emptyCtime() {}
outu !emptyCtime()
mov !ldReg(65)
outc !emptyCtime()
outc 10

; reg preservation
%macro generate3(dbg) {
	%ldReg(1)
	str %dbg
	bmeq end
	outc %dbg

	str 1
	str<r
	strar
	swap
}
%macro move2act() {
	mov !generate3(66)
	mov< !generate3(0)
}
%macro store5() {
	%move2act()
	str !generate3(89)
	stra 2
}
%macro act() { 
	%store5()
	ldm ; 5
}
%macro m() {
	ld 4
	mov 0
	str !act()
	outuh
	ldm ; return 5 (stored retval)
}
%move2act()
outu !m()
outc 32
outuh
ld !generate3(36)


; macros in arglists
%macro ldEmit(b) {
	ld %b
	outur
}
%macro add(a) {
	%ldEmit(%a)
	lda 1
}
%macro endl() {
	outc 10
}
ld !endl()
outc !add(9)
; ^ delim ^
outu !add(!add(4))
%add(!add(3))

%endl()
:_(!add(7)) ; NOTE output changes with label addr
outu _(!ldEmit(8))


%macro seeAsmLength(mac) {
	strp
	%mac
	ldp
	ldsm
	lds 1
	outur
}
; mix of % and !
%endl()
%seeAsmLength(
	%add(7)
)
%seeAsmLength(
	outu !add(6)
)
%ldEmit(
	!seeAsmLength(
		outc 10
		outc 62
		outu !add(4)
	)
)

%macro exec_order1() { outu 1 }
%macro exec_order2() {
	outu 2
	ld !exec_order1()
	outu 3
}
%macro exec_order() {
	outu 4
	ld !exec_order2()
	outu 5
	outc 10
}
ld !endl()
ld !exec_order()

