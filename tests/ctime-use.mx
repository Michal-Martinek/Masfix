; tests errors with using ctimes in contexts of preprocessing, instructions, labels x complex idents, strings

%include "io"

%macro m(b) {
	ld %b
	; outur
}
%macro add(a) {
	%m(%a)
	lda 1
}

; syntactical
!
%!
!define
!m()
ld !m(5)
!m(5)!m
!m(2) %m
two !m(5) !m(5)


ctime !m(3) ld !m(4)
:lab(!add(6))
oui(!add(65535))
jmp lab7 ; labelDefined?
jmp labNO

; syntactically against label definition 
:!m(z)
: !m(2)
: l!m(z)

:"!m(z)"
:(!m(c))
:(!m(2))
:("!m(z)")
: "l"!m(3)
: "l"(!m(3))
: ("l")!m(3)
: ("l")(!m(69))
outu 69 ; good

!m(2) ""
ld "s"!m(2)
ld (t)!m(2)
debug ("i") !m(3) 



; TODO label then ctime
; :goto !proper_instr_gen()

; testing of recursive ctime-meets
%macro deep_forward_expansion1() {}
	%macro deep_forward_expansion2() {
		!deep_forward_expansion1()
	}
	%macro deep_forward_expansion() {
		!deep_forward_expansion2()
	}
ld !deep_forward_expansion()

%macro exec_order1() { outu 1 }
	%macro exec_order2() {
		outu 2
		ld !exec_order1()
		outu 3
	}
	%macro exec_order() {
		outu 4
		ld !exec_order2()
		outu 5
		outc 10
	}
; ld !exec_order()



; březiněves final boss
; :ld(!()) ou(t)(!c()) !oo()(!num())
