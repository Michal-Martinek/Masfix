
%include "memory"
%include "math"
%include "procedures"
%include "control"
%include "io"
%include "debug"

:test_start

%macro callOp(op, numerator, denominator) {
	%stack:push(%numerator)
	%stack:push(%denominator)
	%call(%op)
	%stack:pop()
}
%macro testOp(op, char_u, numerator, denominator) {
	outu %numerator
	outc %char_u
	outu %denominator
	outc 61
	%callOp(%op, %numerator, %denominator)
	outur
}
%macro testDivRem(numerator, denominator) {
	%testOp(divide, 47, %numerator, %denominator)
	outc 37
	mov %MEMORY_LAYOUT:SEG_TEMP
	ldt %denominator
	str %numerator
	strsr
	outum
	outc 10
}
%macro testPower(a, b) {
	%testOp(power, 94, %a, %b)
	outc 10
}

%testDivRem(0, 1)
%testDivRem(0, 5)
%testDivRem(1, 1)
%testDivRem(1, 30)
%testDivRem(32169, 2)
%testDivRem(10, 3)
%testDivRem(512, 8)
%testDivRem(512, 1024)
%testDivRem(89, 13)

outc 10
%testPower(1, 1)
%testPower(1, 0)
%testPower(0, 1)
%testPower(0, 0)
%testPower(10, 1)
%testPower(10, 0)
%testPower(2, 2)
%testPower(2, 10)
%testPower(3, 8)
%testPower(10, 4)
%testPower(213, 2)
%testPower(3, 9)
%testPower(7, 5)
outc 10

; b in r
%macro callPwrStrLocal(a, localIdx) {
	; outc 65
	%stack:push(%a)
	%stack:pushr()
	%call(power)
	%stack:pop()
	%seg:local(%localIdx, strr)
}

; which power to break -> status
%func {test2Powers, 1, 2,
	; locals: maxPwr, currPwr
	%print_spaced(outc 105) ; collumn headers
	%print_spaced(
		outu 2
		outc 94
		outc 105
	)
	outc 47
	outc 10

	ld 14
	%callPwrStrLocal(2, 0) ; maxPwr = 2 ** 14
	ld 15
	%for {
		%stack:top()
		%print_spaced(outur)
		
		%callPwrStrLocal(2, 1) ; currPwr = 2 ** idx
		%print_spaced(outum)

		%seg:push(%local, 0)
		%seg:push(%local, 1)
		%call(divide) ; maxPwr / currPwr
:second_divide_return ; stack dump purposes

		%seg:local(0, ldm)
		%stack:over(1)
		ld>m ; r = maxPwr >> idx
		%stack:pushr()
		outur

		; force error on arg0
		%if {
			%seg:arg(0, ld&m)
		,
			%stack:top()
			stra 1
		}

		%if {
			%stack:pop()
			%stack:drop()
			lnem ; maxPwr >> idx != divide(maxPwr, currPwr)
		,
			outc 32
			outc 69 ; emit error
			outc 64
			%stack:top()
			%print_endl(outum) ; idx
			%return_imm(test2Powers, 69) ; return when values mismatch
		}
		outc 10
	}
	%print_spaced(
		outc 79 ; OK
		outc 75
	)
	%stack:reserve(5) ; test correct stack alignment on function exit
	ld 0 ; retval
}

; little bit also func & debug test
%macro testTest2powers(value) {
	%stack:push(%value)
	%call(test2Powers)
	%print_endl(
		%stack:pop()
		outur
	)
	outc 10
}

%macro showLabelOffset(label, retaddrLocation) {
	; showing label addr disabled for annoying false positives
	; ld %label
	; lds test_start
	; outur
	outc 45
	mov %retaddrLocation
	strs test_start
	str 1234 ; --
	outc 10
}

%void_func {main, 0, 1,
	%seg:local(0, str 66)
	%stack:push(42) ; should stay untouched

	%testTest2powers(0)
	%testTest2powers(!op(<, 1, 10)) ; break at 4th itr
:test_return

	%print_endl(
		%seg:move(%local, 0)
		outum
	)
	%print_endl(
		%stack:top()
		outur
	)
	outc 10

	%print_endl(
		outc 76
		outc 115
	)
	%showLabelOffset(module_end, 17)
	%showLabelOffset(test_return, 23)
	%showLabelOffset(second_divide_return, 32)

	%stack:top()
	%dumpStackOverrun(18)
}

%macro testRounding(value) {
	%stack:push(%value)
	%print_spaced( outum )
	%print_spaced(
		outc 45
		outc 62
	)
	%call(round_up_to_2_power)
	%print_endl(
		%stack:pop()
		outum
	)
}
%testRounding(0)
%testRounding(1)
%testRounding(3)
%testRounding(4)
%testRounding(7)
%testRounding(55)
%testRounding(150)
%testRounding(1000)
%testRounding(10000)
%testRounding(%int_max)
%testRounding(%int_min)
; after it returns uint_max instead
%testRounding(!op(a, %int_min,  1))
%testRounding(!op(s, %uint_max, 1))
%testRounding(%uint_max)

outc 10

%call(main)
:module_end
