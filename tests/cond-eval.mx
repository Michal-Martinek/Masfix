; tests all conditions and branches
%include "memory"
%include "control"

; print condition headers
outc 101
outc 113
outc 124
outc 110
outc 101
outc 124
outc 108
outc 116
outc 124
outc 108
outc 101
outc 124
outc 103
outc 116
outc 124
outc 103
outc 101
outc 10

; memory
%define currTested 8
%define stage1done 10
%define strTemp 11

%store(%currTested, 0)
%store(%stage1done, 0)


%macro testCond(cond, rhs, end) {
	%load(%currTested)
	ld 65535
	lm(%cond) 0 ;%rhs
	%stack:pushr()

	%load(%currTested)
	mov %strTemp
	str 65535
	s(%cond) 0 ;%rhs
	%stack:pushm()

	%stack:push(branch_ret_(%cond)(%rhs))
	%if_else { ld %rhs,
		%stack:over(1) ; if nonzero rhs - cannot test branch: emulate answer from s ^
		ldm
		jmp branch_end
	,
		%load(%currTested)
		bm(%cond) branch_true
		jmp branch_false
	}
:branch_ret_(%cond)(%rhs)
	%if { ld %end,
		outc %end
	}
}

mov %currTested
outum
outc 10

:loop

; tests
%testCond(eq, 0, 0)
%testCond(eq, 1, 124)
%testCond(ne, 0, 0)
%testCond(ne, 1, 124)
%testCond(lt, 0, 0)
%testCond(lt, 1, 124)
%testCond(le, 0, 0)
%testCond(le, 1, 124)
%testCond(gt, 0, 0)
%testCond(gt, 1, 124)
%testCond(ge, 0, 0)
%testCond(ge, 1, 10)


; increments
mov %currTested
stra 1

ldm
lds 6
bne stage1_end
outc 10
str 32765
outum
outc 10

%store(%stage1done, 1)
mov %currTested
jmp loop

:stage1_end
ldm
lds 32771
bne stage2_end
outc 10
str 65533
outum
outc 10
jmp loop

:stage2_end
lmeq 3 ; end if (curr == 2) && stage1_done
mov %stage1done
ld&m
beq loop
jmp end

; branch outcomes
:branch_true
ld 1
jmp branch_end

:branch_false
ld 0

%macro compare() {
	ldsm
	bne error
	ldm
}
:branch_end
%stack:dropN(2)
%stack:drop()
%compare()
mova 1
%compare()
outur
jmp branch_ret

:error
	outc 69

:branch_ret
mova 1
jmpm
