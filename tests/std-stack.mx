

%include "std/memory"
%using stack

%load(%MEMORY_LAYOUT:G_STACK_PTR)
outur
%top()
str 11 ; forbidden
ld !push(66)

outc 10

; VM
mov 5
%macro ad(val) {
	%stack:push(%val)
	ldh
	outuh
	outc 32
}
ld !ad(7) ; 18_
outu !stack:pop() ; 7
outuh ; 5
outc 10

; clear VM stack
outc 67
outu !pop()
outu !load(%MEMORY_LAYOUT:G_STACK_PTR) ; STACK should be empty
outc 10

; runtime -----------------------------
%ad(9) ; 17
%stack:pop() ; 9
outur
outc 10

; %pushr()
%push(1)
mov 69
%push(2)
movs 13
%push(3)

ld 4
%pushr()
lda 1
%pushr()
lda 1
mov< 3
%pushr() ; 6
lda 1

%pop()
outum
mov 14
%pop()
outum
%top() ; 4, not eaten
outum
outc 10

; over, dup_over, ld_over, reserve, dropN, movptr
%push(1)
%push(2)
%push(3)
%push(4)
%push(5)

ld 6 ; over preserving r
%over(0) ; stack top
outuh ; sp=25
outur
outum ; 5

%dup_over(2) ; push 3
%ld_over(5) ; 1
outur

outc 32
%reserve(3)
%top()
outuh ; 29
outc 32

ld 3
%drop()
%dropN(2)
outur
; keep result of dup_over(2) ^ (not at stack:top)
%top()
ldh
%storer(%MEMORY_LAYOUT:SEG_TEMP)
%dropN(4)
%movptr(%MEMORY_LAYOUT:SEG_TEMP)
%pushm()

outc 10

%top()
:pop_all_loop
	ldh
	lds 1
	lgt %MEMORY_LAYOUT:SEG_STACK
	beq loop_end

	%pop()
	outum
	jmp pop_all_loop
:loop_end
outc 10
