%include "memory"

; source of incrementing numbers
%namespace iota {
	%using MEMORY_LAYOUT
	%macro get() {
		%load(%G_IOTA)
	}
	%macro increment() {
		%load(%G_IOTA)
		stra 1
	}

	%macro get_offset(off) {
		%get()
		lda %off
	}
	%macro get_prev() {
		%get_offset(65535)
	}
	%macro get_next() {
		%get_offset(1)
	}

	;; iota assisted labels
	%macro instr_with_label(instr, label_name) {
		%instr (%label_name)_(!get())
	}
	; one iota number per expansion
	; at macro end use !increment() / define last label with _increment variant
	%macro def_label(name) {
		: (%name)_(!get())
	}
	%macro def_label_increment(name) {
		: (%name)_(!increment())
	}
}
%using iota

; NOTE cond - loads boolean condition to r
%macro if(cond, body) {
		%cond
	%instr_with_label(beq, if)
		%body
	%def_label_increment(if)
}
%macro if_else(cond, body, else) {
		%cond
	%instr_with_label(beq, else)
		%body
		%instr_with_label(jmp, else_end)
	%def_label(else)
		%else
	%def_label_increment(else_end)
}

; loops
%macro loop_continue() {
	; TODO breaks when inside %if
	%instr_with_label(jmp, while_continue)
}
%macro loop_break() {
	%instr_with_label(jmp, while_end)
}
%macro do_while(cond, body) {
	%def_label(do_start)
		%body
	%def_label(while_continue)
		%cond
		%instr_with_label(bne, do_start)
	%def_label_increment(while_end)
}
%macro while(cond, body) {
	%def_label(while_continue)
		%cond
		%instr_with_label(beq, while_end)
		%body
		%loop_continue()
	%def_label_increment(while_end)
}

; stop - r
; curr idx @stack:top
; step must be positive
; r - volatile, ends with 0
%macro for_full(start, step, body) {
	%stack:pushr() ; stop
	%stack:push(%start) ; idx
	%while {
		%stack:top()
		movs 1
		lltm ; idx < stop
	,
		%body
		%stack:top() ; idx += step
		stra %step
	}
	%stack:drop()
	%stack:drop()
}

%macro for(body) {
	%for_full(0, 1, %body)
}
