
%include "memory"
%include "control"
%include "procedures"
%include "math"
%include "structs"
%include "exceptions"

; ptr, count, value
; sets @count entries starting @ptr to @value
%void_func{ memset, 3, 0,
	; locals: inc ptr, dec count
	%func_arg(1)
	%while { ; count > 0
		lmab 0
	,
		; mem[ptr++] = value
		%seg:arg(2, ldm)
		%seg:arg(0,
			stra 1
			movms 1
			strr
		)
		%seg:arg(1, strs 1) ; count --
	}
}
; from, to, count
; copies @count words
; correct even if from&to areas overlap
%void_func{ memcopy, 3, 1,
	; args as locals  | direction
	%seg:local(0, str 1)
	%if { ; from < to: reverse directions (copy from end to begin)
		%seg:arg(0, ldm)
		%seg:arg(1, lrltm)
	,
		%seg:arg(2, ldms 1) ; ptrs += count - 1
		%seg:arg(0, strar)
		%seg:arg(1, strar)
		%seg:local(0, str %minus1) ; direction = -1
	}
	%func_arg(2)
	%while { ; count > 0
		lmab 0
	,
		; mem[to] = mem[from]
		%seg:arg(0,
			movm
			ldm
		)
		%seg:arg(1,
			movm
			strr
		)
		%seg:local(0, ldm)  ; ptrs += dir
		%seg:arg(0, strar)
		%seg:arg(1, strar)
		%seg:arg(2, strs 1) ; count --
	}
}

; memory is split into linear chunks:
; chunks have 2-word header = data_size, flags
; data follows after header
%namespace chunk {
	%struct:begin()
	%struct:field(data_size, 1)
	%struct:field(flags, 1)
	%struct:field(data_offset, 0) ; unknown

	%define FLAG_FREE 0
	%define FLAG_OCCUPIED 1

	; all macros expect @chunk header
	%macro size() {
		ldm
	}
	%macro free() {
		mova %flags
		lmeq %FLAG_FREE
	}
	%macro occupied() {
		mova %flags
		lmeq %FLAG_OCCUPIED
	}
	; moves to next chunk's header
	%macro next() {
		movama %data_offset ; data_size + 2
	}

	%struct:end()
}

; organized as linear stack (each chunk points to next)
; searched from start till empty chunk is found
%namespace heap {
	%using MEMORY_LAYOUT

	%define FIRST_CHUNK_HEADER (%SEG_HEAP)

	%macro initHeap() {
		; one big chunk spanning whole heap
		mov %FIRST_CHUNK_HEADER
		str !op(s, %SEG_DEBUG_GLOBALS, %FIRST_CHUNK_HEADER)
		strs 4 ; 1 + sizeof(header)
		; TODO better heap ending
		mova %chunk:flags
		str %chunk:FLAG_FREE
	}
	%initHeap()
	%nop(!initHeap())

	; size -> ptr
	; reserves at least @size words, returns pointer to start of data array
	%func {malloc, 1, 1,
		; locals: *currChunk
		%assert(%seg:arg(0, lmab 0))
		%seg:local(0, str %FIRST_CHUNK_HEADER)
		%while {
			; chunkSize < size || occupied
			%seg:local(0, movm)
			%chunk:size()
			%stack:pushr() ; save chunkSize

			%seg:arg(0, lrblm)
			%stack:pushr()

			%seg:local(0, movm)
			%chunk:occupied()
			%stack:pushr()

			%stack:apply_op(|)
			%stack:pop()
		,
			%stack:drop() ; chunk_size
			; mov to next chunk
			%seg:local(0, movm)
			%chunk:next()
			ldh
			%seg:local(0, strr)
		}
		; TODO check not at end

		; if chunk_size - size > 3
		%if_else {
			%seg:arg(0, ldm)
			%stack:drop() ; chunk size
			strsr
			lmab 3
		,
			;; split chunk
			; curr.size = size, next.size = total_size
			%seg:arg(0, ldm)
			%seg:local(0,
				movm
				swap
			)
			%chunk:next()
			strr
			ldh
			; curr.occupied, r = size
			%seg:local(0,
				movm
				ldm
			)
			%chunk:at(flags)
				str %chunk:FLAG_OCCUPIED
			movs %chunk:flags
			; next.size -= size + 2
			%chunk:next()
			strsra 2
			; next.free
			%chunk:at(flags)
			str %chunk:FLAG_FREE
		,
			; reserve whole
			%seg:local(0, movm)
			%chunk:at(flags)
			str %chunk:FLAG_OCCUPIED
		}
		; return data ptr
		%seg:local(0, ldma 2)
	}

	; free segment @ data_ptr
	%void_func {free, 1, 0,
		%seg:arg(0, movm)
		movs %chunk:data_offset
		%assert(ldm)
		%chunk:at(flags)
		%assert(lmeq %chunk:FLAG_OCCUPIED)
		str %chunk:FLAG_FREE
	}
}
