%include "memory"
%using stack
%using MEMORY_LAYOUT

;; basic procedures -----------------------------------
;; handle only return address

; proc definition: after body expects retval in reg %where_retaddr
%macro _proc_impl(name, where_retaddr, body) {
		jmp proc_(%name)_body_end ; skip over proc body
	:proc_(%name) ; entry
		%body
		jmp(%where_retaddr)
	:proc_(%name)_body_end
}
; proc definition - calling&returning, no args/locals/retval
; preserves r, expects retaddr @top
%macro proc(name, body) {
	%_proc_impl(%name, m,
		%body
		%stack:drop() ; mov to retaddr
	)
}
; call proc / func
%macro call(name) {
	%push(2) ; ret addr offset
	strap
	jmp proc_(%name)
	%stack:top() ; load retval for ctime
}
; call proc / func by ptr in r
%macro call_ptr() {
	%push(2) ; ret addr offset
	strap
	jmpr
	%stack:top()
}

;; functions ---------------------------------
;; allow argument passing, local variables and returning
;; safe even with misaligned stack after function body
;; funcs properly preserve memory segments (args, locals) even when nested

; saves ARGS, LOCALS segment pointers of caller by pushing in function prologue (above retaddr)
%macro _push_segment_ptrs() {
	; TODO optimization - save only in non-leaf funcs
	mov %MEMORY_LAYOUT:G_ARGS_PTR
	%stack:pushm()
	mov %MEMORY_LAYOUT:G_LOCALS_PTR
	%stack:pushm()
	; TODO save G_this_ptr
}
; reset SP to expected length, restore caller's segments, pop retaddr -> r
%macro _rstSP_pop_segment_ptrs() {
	%load(%MEMORY_LAYOUT:G_LOCALS_PTR)
	%storer(%MEMORY_LAYOUT:G_STACK_PTR)
	strs 1 ; SP = locals-1
	%stack:pop()
	%storer(%MEMORY_LAYOUT:G_LOCALS_PTR)
	%stack:pop()
	%storer(%MEMORY_LAYOUT:G_ARGS_PTR)
	%stack:pop() ; retaddr
}

; TODO auto reserve space for retval when args = 0

; safe when stack grows in func body
; volatile r on entry/exit
%macro _func_impl(name, args, drop_args, locals, body) {
	; function frame: stack top of prev func-| A1..An retaddr seg_args seg_locals L1..Ln
	%_proc_impl(%name, r,
		%_push_segment_ptrs()
		ldh ; r = &retaddr + 2 (segments)
		%storer(%G_LOCALS_PTR) ; LOCALS = top() + 1
		stra 1
		%stack:reserve(%locals) ; reserve space for locals (above saved segments)

		lds !op(a, %args, 2)
		%storer(%G_ARGS_PTR) ; ARGS = &retaddr - #args

		%body
	:return_(%name) ; function epilogue - jump here to exit func (doesn't save retval!)
		%_rstSP_pop_segment_ptrs()
		%stack:dropN(%drop_args) ; drop #drop_args
		; retaddr in r
	)
}
; args on stack
; args, locals - number of vars to reserve
; volatile r
%macro void_func(name, args, locals, body) {
	%_func_impl(%name, %args, %args, %locals,
		%body
	)
}
; caller: push args on stack - auto removed after, retval appears "pushed" instead
; callee: returns value in r on function end (see function returning)
; args, locals - number of vars to reserve
; !! args must be >= 1 (space for retval)
%macro func(name, args, locals, body) {
	%_func_impl(%name, %args, !op(s, %args, 1), %locals,
		%body
		%save_retval() ; return r
	)
}

; same as %func + saves first arg to G_THIS_PTR
; first argument must be ptr to instance
%macro method(name, args, locals, body) {
	%func(%name, %args, %locals,
		%seg:arg(0, %storem(%this))
		%body
	)
}
%macro void_method(name, args, locals, body) {
	%void_func(%name, %args, %locals,
		%seg:arg(0, %storem(%this))
		%body
	)
}

;; function returning ------------------------

; saves retval from r
%macro save_retval() {
	%seg:arg(0, strr)
}
; ends function execution without affecting retval
%macro returnFunc(funcName) {
	jmp return_(%funcName)
}
; return value in r and exit function
%macro returnr(funcName) {
	%save_retval()
	%returnFunc(%funcName)
}
%macro return_imm(funcName, imm) {
	%seg:arg(0, str %imm)
	%returnFunc(%funcName)
}

;; data segments ---------------------------------------------------
;; namespace seg is not meant for including
;; arg   - current function arguments
;; local - current function local variables
;; this  - current instance in methods
;; src   - object pointed to by G_SRC
;; dest  - object pointed to by G_DEST
;; temp  - segment for temporary values - volatile!

%define arg   (%MEMORY_LAYOUT:G_ARGS_PTR)
%define local (%MEMORY_LAYOUT:G_LOCALS_PTR)
%define this  (%MEMORY_LAYOUT:G_THIS_PTR)
%define src   (%MEMORY_LAYOUT:G_SRC)
%define dest  (%MEMORY_LAYOUT:G_DEST)
%define temp  (%MEMORY_LAYOUT:SEG_TEMP)
%namespace seg {
	;; use ^ for name arg

	; push segment address
	%macro push_addr(name, idx) {
		mov %name
		ldma %idx
		%stack:pushr()
	}
	; move to segment
	%macro move(name, idx) {
		mov %name
		movma %idx
	}
	; load segment value
	%macro load(name, idx) {
		%move(%name, %idx)
		ldm
	}
	; store r in segment
	%macro store(name, idx) {
		%move(%name, %idx)
		strr
	}
	; push segment value
	%macro push(name, idx) {
		%move(%name, %idx)
		%stack:pushm()
	}
	; pop stack to segment
	%macro pop(name, idx) {
		%stack:pop()
		%store(%name, %idx)
	}

	%macro arg(idx, instrs)   { %_func_seg(%MEMORY_LAYOUT:G_ARGS_PTR,   %idx, %instrs) }
	%macro local(idx, instrs) { %_func_seg(%MEMORY_LAYOUT:G_LOCALS_PTR, %idx, %instrs) }
	%macro this(idx, instrs)  { %_func_seg(%MEMORY_LAYOUT:G_THIS_PTR,   %idx, %instrs) }
	%macro src(idx, instrs)   { %_func_seg(%MEMORY_LAYOUT:G_SRC,        %idx, %instrs) }
	%macro dest(idx, instrs)  { %_func_seg(%MEMORY_LAYOUT:G_DEST,       %idx, %instrs) }
	%macro temp(idx, instrs)  { mov !op(a, %MEMORY_LAYOUT:SEG_TEMP,     %idx)
		%instrs
	}

	;; impl
	%macro _func_seg(ptr_addr, idx, after) {
		mov %ptr_addr
		movma %idx
		%after
	}
}

;; calling functions with constant arguments
%macro callWith1Arg(name, argument) {
	%push(%argument)
	%call(%name)
}
%macro callWith2Arg(name, a, b) {
	%push(%a)
	%push(%b)
	%call(%name)
}
%macro callWith3Arg(name, a, b, c) {
	%push(%a)
	%push(%b)
	%push(%c)
	%call(%name)
}

%include "math"
