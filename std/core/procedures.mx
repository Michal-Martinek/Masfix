%include "memory"
%using stack
%using MEMORY_LAYOUT

; proc definition: after body expects retval in reg %where_retaddr
%macro _proc_impl(name, where_retaddr, body) {
		jmp proc_(%name)_body_end ; skip over proc body
	:proc_(%name) ; entry
		%body
		jmp(%where_retaddr)
	:proc_(%name)_body_end
}
; proc definition - calling&returning, no args/locals/retval
; preserves r, expects retaddr @top
%macro proc(name, body) {
	%_proc_impl(%name, m,
		%body
		%stack:drop() ; mov to retaddr
	)
}
; call proc / func
%macro call(name) {
	%push(2) ; ret addr offset
	strap
	jmp proc_(%name)
	%stack:top() ; load retval for ctime
}

; functions --------------------


; saves ARGS, LOCALS segment pointers of caller by pushing in function prologue (above retaddr)
%macro push_segment_ptrs() {
	; TODO optimization - save only in non-leaf funcs
	mov %MEMORY_LAYOUT:G_ARGS_PTR
	%stack:pushm()
	mov %MEMORY_LAYOUT:G_LOCALS_PTR
	%stack:pushm()
	; TODO save G_this_ptr
}
; reset SP to expected length, restore caller's segments, pop retaddr -> r
%macro rstSP_pop_segment_ptrs() {
	%load(%MEMORY_LAYOUT:G_LOCALS_PTR)
	%storer(%MEMORY_LAYOUT:G_STACK_PTR)
	strs 1 ; SP = locals-1
	%stack:pop()
	%storer(%MEMORY_LAYOUT:G_LOCALS_PTR)
	%stack:pop()
	%storer(%MEMORY_LAYOUT:G_ARGS_PTR)
	%stack:pop() ; retaddr
}

; TODO auto reserve space for retval when args = 0

; safe when stack grows in func body
; volatile r on entry/exit
%macro _func_impl(name, args, drop_args, locals, body) {
	; function frame: stack top of prev func-| A1..An retaddr seg_args seg_locals L1..Ln
	%_proc_impl(%name, r,
		%push_segment_ptrs()
		ldh ; r = &retaddr + 2 (segments)
		%storer(%G_LOCALS_PTR) ; LOCALS = top() + 1
		stra 1
		%stack:reserve(%locals) ; reserve space for locals (above saved segments)

		lds !op(a, %args, 2)
		%storer(%G_ARGS_PTR) ; ARGS = &retaddr - #args

		%body
	:return_(%name) ; function epilogue - jump here to exit func (doesn't save retval!)
		%rstSP_pop_segment_ptrs()
		%stack:dropN(%drop_args) ; drop #drop_args
		; retaddr in r
	)
}
; args on stack
; args, locals - number of vars to reserve
; volatile r
%macro void_func(name, args, locals, body) {
	%_func_impl(%name, %args, %args, %locals,
		%body
	)
}
; caller: push args on stack - auto removed after, retval appears "pushed" instead
; callee: returns value in r on function end (not when called return!)
; args, locals - number of vars to reserve
; !! args must be >= 1 (space for retval)
%macro func(name, args, locals, body) {
	%_func_impl(%name, %args, !op(s, %args, 1), %locals,
		%body
		%save_retval() ; return r
	)
}

; same as %func + saves first arg to G_THIS_PTR
; first argument must be ptr to instance
%macro method(name, args, locals, body) {
	%func(%name, %args, %locals,
		%seg:arg(0, %storem(%this))
		%body
	)
}
%macro void_method(name, args, locals, body) {
	%void_func(%name, %args, %locals,
		%seg:arg(0, %storem(%this))
		%body
	)
}

; saves retval from r
%macro save_retval() {
	%func_arg(0)
	strr
}
; ends function execution without affecting retval
%macro returnFunc(funcName) {
	jmp return_(%funcName)
}
%macro returnr(funcName) {
	%save_retval()
	%returnFunc(%funcName)
}
%macro return_imm(funcName, imm) {
	%func_arg(0)
	str %imm
	%returnFunc(%funcName)
}

%macro func_arg(idx) {
	%movptr(%G_ARGS_PTR)
	mova %idx
}
%macro func_local(idx) {
	%movptr(%G_LOCALS_PTR)
	mova %idx
}
%define arg   (%MEMORY_LAYOUT:G_ARGS_PTR)
%define local (%MEMORY_LAYOUT:G_LOCALS_PTR)
%define this  (%MEMORY_LAYOUT:G_THIS_PTR)
%define src   (%MEMORY_LAYOUT:G_SRC)
%define dest  (%MEMORY_LAYOUT:G_DEST)
%namespace seg {
	; use ^ for name
	%macro push_addr(name, idx) {
		mov %name
		ldma %idx
		%stack:pushr()
	}
	%macro _func_seg(ptr_addr, idx, after) {
		mov %ptr_addr
		movma %idx
		%after
	}
	%macro arg(idx, instrs)   { %_func_seg(%MEMORY_LAYOUT:G_ARGS_PTR,   %idx, %instrs) }
	%macro local(idx, instrs) { %_func_seg(%MEMORY_LAYOUT:G_LOCALS_PTR, %idx, %instrs) }
	%macro this(idx, instrs)  { %_func_seg(%MEMORY_LAYOUT:G_THIS_PTR,   %idx, %instrs) }
	%macro src(idx, instrs)   { %_func_seg(%MEMORY_LAYOUT:G_SRC,        %idx, %instrs) }
	%macro dest(idx, instrs)  { %_func_seg(%MEMORY_LAYOUT:G_DEST,       %idx, %instrs) }
	%macro temp(idx, instrs)  { mov !op(a, %MEMORY_LAYOUT:SEG_TEMP,     %idx)
		%instrs
	}
}

; calling functions with constant arguments
%macro callWith1Arg(name, argument) {
	%push(%argument)
	%call(%name)
}
%macro callWith2Arg(name, a, b) {
	%push(%a)
	%push(%b)
	%call(%name)
}
%macro callWith3Arg(name, a, b, c) {
	%push(%a)
	%push(%b)
	%push(%c)
	%call(%name)
}

%include "math"
