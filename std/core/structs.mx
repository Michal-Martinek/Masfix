%include "memory"
%include "math"
%include "exceptions"


%namespace struct {
	%macro defineLocalMacros() {
	;; creation & destruction
		; allocate new uninitialized instance on heap
		; new ptr -> stack
		%macro new() {
			%callWith1Arg(malloc, %sizeof)
		}
		; free struct from heap
		%macro dealloc() {
			ldh
			%stack:pushr()
			%call(free)
		}
		; copies struct values to new instance on heap
		; -> copied @stack
		%macro shallow_copy() {
			ldh ; temp store this
			mov !op(a, %MEMORY_LAYOUT:SEG_TEMP, 3)
			strr
			%new()
			mov !op(a, %MEMORY_LAYOUT:SEG_TEMP, 3)
			%stack:pushm() ; new, this
			%stack:dup_over(1)
			%stack:push(%sizeof) ; new | this, new, count
			%call(memcopy)
			; -> new
		}

	;; accessing
		%macro at(field) {
			mova %(%field)
		}
		%macro reset(from_field) {
			movs %(%from_field)
		}
		; does op at field, restores position to struct start
		%macro do_at(field, op) {
			%at(%field)
			%op
			%reset(%field)
		}
		%macro set(field, value) {
			%do_at(%field, str %value)
		}

		%macro default_print() {
			%stack:pushh()
			%stack:push(%sizeof)
			%call(memdump)
		}
	}

	;; missing definition parts prevention
	%nop(!store(%MEMORY_LAYOUT:G_STRUCT_OFFSET, %uint_max)) ; signalizes uninitialized
	%macro __assert_init_state(cond) {
		%nop(!assert(
			%load(%MEMORY_LAYOUT:G_STRUCT_OFFSET)
			l(%cond) %uint_max
		))
	}
	%macro _assert_initialized()   { %__assert_init_state(ne) }
	%macro _assert_uninitialized() { %__assert_init_state(eq) }

	%macro begin() {
		%_assert_uninitialized()
		%define struct_id 0 ; prevent struct redefinitions
		%nop(!store(%MEMORY_LAYOUT:G_STRUCT_OFFSET, 0))
		%defineLocalMacros()
	}
	%macro _get_increment_offset(field_size) {
		%load(%MEMORY_LAYOUT:G_STRUCT_OFFSET)
		stra %field_size
	}
	%macro field(name, size) {
		%_assert_initialized()
		%define (%name) (!_get_increment_offset(%size))
	}
	%macro end() {
		%_assert_initialized()
		%define sizeof (!load(%MEMORY_LAYOUT:G_STRUCT_OFFSET))
		%nop(!store(%MEMORY_LAYOUT:G_STRUCT_OFFSET, %uint_max))
	}
}
