%include "memory"

; source of incrementing numbers
%namespace iota {
	%using MEMORY_LAYOUT
	%macro get() {
		%load(%G_IOTA)
	}
	%macro get_offset(off) {
		%get()
		lda %off
	}
	%macro get_prev() {
		%get_offset(65535)
	}
	%macro get_next() {
		%get_offset(1)
	}

	%macro increment() {
		%load(%G_IOTA)
		stra 1
	}
	%macro def_label(name) {
		: (%name)_(!increment())
	}
}
%using iota

; NOTE cond - loads boolean condition to r
%macro if(cond, body) {
	%cond
	beq if_(!iota:get())
	%body
	%def_label(if)
}
%macro if_else(cond, body, else) {
	%cond
	beq else_(!iota:get())
		%body
		jmp else_end_(!iota:get_next())
	%def_label(else)
		%else
	%def_label(else_end)
}
%macro do_while(cond, body) {
	%def_label(do_start)
	%body
	%cond
	bne do_start_(!iota:get_prev())
}
%macro while(cond, body) {
%def_label(while_start)
	%cond
	beq while_end_(!iota:get())
	%body
	jmp while_start_(!iota:get_prev())
%def_label(while_end)
}

; stop - r
; curr idx @stack:top
; r - volatile
%macro for_full(start, step, body) {
	%stack:pushr() ; stop
	%stack:push(%start) ; idx
	%while {
		%stack:top()
		movs 1
		lltm ; idx < stop
	,
		%body
		%stack:top() ; idx += step
		stra %step
	}
	%stack:drop()
	%stack:drop()
}

%macro for(body) {
	%for_full(0, 1, %body)
}
