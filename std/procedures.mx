%include "memory"
%using stack
%using MEMORY_LAYOUT

; proc definition: after body expects retval @h
%macro _proc_impl_reth(name, body) {
		jmp proc_(%name)_body_end ; skip over proc body
	:proc_(%name) ; entry
		%body
		jmpm
	:proc_(%name)_body_end
}
; proc definition - calling&returning, no args/locals/retval
; preserves r, expects retaddr @top
%macro proc(name, body) {
	%_proc_impl_reth(%name,
		%body
		%stack:drop() ; mov to retaddr
	)
}
; call proc, void func, valued func - returns @stack:top()
%macro call(name) {
	%push(2) ; ret addr offset
	strap
	jmp proc_(%name)
	%movptr(%G_STACK_PTR) ; mov retval
}

; functions --------------------

; TODO calling inside func - saving locals&args
; TODO auto reserve space for retval when args = 0

; epilogue preserves r, expects stack to stay same size
%macro _func_impl(name, args, drop_args, locals, body) {
	%_proc_impl_reth(%name,
		ldh ; &retaddr
		%storer(%G_LOCALS_PTR) ; LOCALS = &retaddr + 1
		stra 1
		mov %G_STACK_PTR ; reserve space for locals
		stra %locals

		lds %args
		%storer(%G_ARGS_PTR) ; ARGS = &retaddr - #args

		%body
	:return_(%name) ; function epilogue - jump here to exit func (doesn't save retval!)
	; TODO set SP = ARGS + (has_retval?) - ignore all pushed values in func
		%stack:dropN(!op(a, %locals, !op(a, %drop_args, 1))) ; drop #drop_args + #locals + 1 (retaddr)
		%movptr(%G_LOCALS_PTR)
		movs 1 ; mov to retaddr
	)
}
; args on stack
; args, locals - number of vars to reserve
; preserves r on return
%macro void_func(name, args, locals, body) {
	%_func_impl(%name, %args, %args, %locals,
		%body
	)
}
; args on stack, retval on stack
; args, locals - number of vars to reserve
; preserves r on return
; !! args must be >= 1 (space for retval)
%macro func(name, args, locals, body) {
	%_func_impl(%name, %args, !op(s, %args, 1), %locals,
		%body
		%save_retval() ; return r
	)
}

; saves retval from r
%macro save_retval() {
	%func_arg(0)
	strr
}
%macro func_arg(idx) {
	%movptr(%G_ARGS_PTR)
	mova %idx
}
%macro func_local(idx) {
	%movptr(%G_LOCALS_PTR)
	mova %idx
}

; calling functions with constant arguments - possible retval @h
%macro callWith1Arg(name, arg) {
	%push(%arg)
	%call(%name)
}
%macro callWith2Arg(name, a, b) {
	%push(%a)
	%push(%b)
	%call(%name)
}
%macro callWith3Arg(name, a, b, c) {
	%push(%a)
	%push(%b)
	%push(%c)
	%call(%name)
}

%include "math"
