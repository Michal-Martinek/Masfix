
%include "procedures"
%include "control"
%include "memory"
%using MEMORY_LAYOUT
%include "io"
%include "math"

%store(%SEG_DEBUG_GLOBALS, %SEG_DEBUG_STACK) ; INIT debug SP

%macro _swapGlobalCell(idx) {
	%loadmov(!op(a, %SEG_GLOBAL, %idx), !op(a, %SEG_DEBUG_GLOBALS, %idx))
	swap
	%storer(!op(a, %SEG_GLOBAL, %idx))
}
; toggle between normal mode and debug mode
; (swap global segments)
%macro toggleDebugMode() {
	%_swapGlobalCell(0)
	%_swapGlobalCell(1)
	%_swapGlobalCell(2)
	%_swapGlobalCell(3)
	%_swapGlobalCell(4)
	%_swapGlobalCell(5)
	%_swapGlobalCell(6)
	%_swapGlobalCell(7)
}

%macro emitMemdumpAddr() {
	outc 10
	outuh
	outc 58
}

; from, count -> void (stdout)
%void_func {memdump, 2, 0,
	%func_arg(1) ; ld count
	ldm
	%for {
		%stack:top() ; idx
		%func_arg(0) ; from
		movm
		movar ; *(from + idx)

		%if {
			ldh ; line start
			ld& 7 ; 8 per line
			leq 0
		,
			%emitMemdumpAddr()
		}

		; TODO padded outum
		outc 32
		outum

	}
}

%macro _dumpStackPrologue() {
	outc 10
	%print_key_val(114, r)
	%print_key_val(104, h)
	%print_key_val(109, m)
	mov %G_STACK_PTR ; "0: <SP>"
	%print_spaced(%emitMemdumpAddr())
	outum
	%toggleDebugMode()
}
%macro _dumpStack2Top() {
	%_dumpStackPrologue()
	%stack:push(%SEG_DEBUG_GLOBALS) ; memdump(SP+1, 7)
	stra 1
	%stack:push(7)
	%call(memdump)
	%stack:push(8) ; memdump from 8
	%load(%SEG_DEBUG_GLOBALS)
	lds 7
	%stack:pushr() ; count: original SP - 7
	%call(memdump)
}

%macro dumpStack() {
	%_dumpStack2Top()
	outc 10
	jmp end
}
%macro dumpStackOverrun(overrun) {
	%_dumpStack2Top()
	; show overrun
	outc 124 ; separator
	%load(%SEG_DEBUG_GLOBALS)
	lda 1
	%stack:pushr() ; from original SP
	%stack:push(%overrun) ; count
	%call(memdump)
	outc 10
	jmp end
}

%macro seeFuncFrame() {
	outc 10
	outc 70
	outc 58

	%load(%G_LOCALS_PTR) ; memdump(locals:top)
	%stack:pushr()
	%load(%G_STACK_PTR)
	mov %G_LOCALS_PTR
	ldsm
	%stack:pushr()
	%call(memdump)
	outc 10
}
