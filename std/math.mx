%include "procedures"
%include "memory"
%include "control"

; TODO should these be ctime only macros?

; perform any binary operation (supply only letters)
%macro op(opp, a, b) {
	ld %a
	ld(%opp) %b
}

%define uint_max (!op(s, 0, 1)) ; 11111
%define  int_max (!op(>, %uint_max, 1))        ; 01111
%define  int_min (!op(s, %uint_max, %int_max)) ; 10000

%macro neg(a) {
	ld %a
	ld^ 65535
	lda 1
}

%macro max(a, b) {
	%if_else {
		ld %a
		llt %b
	,
		ld %b
	,
		ld %a
	}
}
%macro abs(a) {
	ld !max(%a, !neg(%a))
}

; a, b -> a / b
; remainder - seg_temp[0]
%func {divide, 2, 1,
	%stack:top() ; local result = 0
	str 0
	%while {
		%func_arg(1) ; a >= b
		ldm
		movs 1
		lmger ; TODO unsigned comparison
	,
		%func_local(0) ; result++
		stra 1
		%func_arg(1) ; a -= b
		ldm
		movs 1
		strsr
	}
	%func_arg(0) ; store remainder
	%storem(%MEMORY_LAYOUT:SEG_TEMP)
	%stack:top() ; return result
}
%macro ld_remainder() {
	%load(%MEMORY_LAYOUT:SEG_TEMP)
}

; a, b -> a ** b
%func {power, 2, 1,
	; local - result
	%func_local(0) ; result = 1
	str 1
	%while {
		; b > 0
		%func_arg(1)
		ldm
	,
		; result *= a
		movs 1 ; a
		ldm
		%func_local(0)
		strtr
		; b--
		%func_arg(1)
		strs 1
	}
	%func_local(0) ; return result
	ldm
}

; num: uint -> 2**k >= num
; num above 2**15 rounds to uint_max
%func {round_up_to_2_power, 1, 1,
	%if { %seg:arg(0, lmab %int_min),
		%return_imm(round_up_to_2_power, %uint_max)
	}
	%seg:local(0, str 1) ; 2 power
	%while {
		%seg:arg(0, ldm)
		%seg:local(0, lmblr)
	,
		str< 1
	}
	ldm
}
